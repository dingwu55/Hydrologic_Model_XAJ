# -*- coding: utf-8 -*-
import json
import pandas as pd
import os
from deap import base, creator
from deap import tools
import random

from typing import Union
from collections import OrderedDict
import numpy as np
from numba import jit

MIN = 0
MAX = 1


class CalibrateXAJ(object):
    def __init__(self):
        self.MIN = 0
        self.MAX = 1

    # @jit
    def calculate_evap(self, lm, c, wu0, wl0, prcp, pet):
        eu = np.where(wu0 + prcp >= pet, pet, wu0 + prcp)
        ed = np.where((wl0 < c * lm) & (wl0 < c * (pet - eu)), c * (pet - eu) - wl0, 0.0)
        el = np.where(wu0 + prcp >= pet, 0.0, np.where(wl0 >= c * lm, (pet - eu) * wl0 / lm,
                                                       np.where(wl0 >= c * (pet - eu), c * (pet - eu), wl0), ), )
        return eu, el, ed

    # @jit
    def calculate_prcp_runoff(self, b, im, wm, w0, pe):
        wmm = wm * (1.0 + b)
        a = wmm * (1.0 - (1.0 - w0 / wm) ** (1.0 / (1.0 + b)))
        if np.isnan(a).any():
            raise ArithmeticError("Please check if w0>wm or b is a negative value!")
        # 1e-5 is a precision which we set to guarantee float's calculation is correct
        r_cal = np.where(pe > 0.0, np.where(pe + a < wmm,
                                            pe - (wm - w0) + wm * (1.0 - np.minimum(a + pe, wmm - 1e-5) / wmm) ** (
                                                    1.0 + b),
                                            pe - (wm - w0), ), np.full(pe.shape, 0.0), )
        r = np.maximum(r_cal, 0.0)
        # separate impervious part with the other
        r_im_cal = pe * im
        r_im = np.maximum(r_im_cal, 0.0)
        return r, r_im

    def calculate_w_storage(self, um, lm, dm, wu0, wl0, wd0, eu, el, ed, pe, r):
        # pe>0: the upper soil moisture was added firstly, then lower layer, and the final is deep layer
        # pe<=0: no additional water, just remove evapotranspiration,
        # but note the case: e >= p > 0
        # (1) if wu0 + p > e, then e = eu (2) else, wu must be zero
        wu = np.where(pe > 0.0, np.where(wu0 + pe - r < um, wu0 + pe - r, um),
                      np.where(wu0 + pe > 0.0, wu0 + pe, 0.0), )
        # calculate wd before wl because it is easier to cal using where statement
        wd = np.where(pe > 0.0, np.where(wu0 + wl0 + pe - r > um + lm, wu0 + wl0 + wd0 + pe - r - um - lm, wd0),
                      wd0 - ed, )
        # water balance (equation 2.2 in Page 13, also shown in Page 23)
        # if wu0 + p > e, then e = eu; else p must be used in upper layer,
        # so no matter what the case is, el didn't include p, neither ed
        wl = np.where(pe > 0.0, wu0 + wl0 + wd0 + pe - r - wu - wd, wl0 - el)
        # the water storage should be in reasonable range
        wu_ = np.clip(wu, a_min=0.0, a_max=um)
        wl_ = np.clip(wl, a_min=0.0, a_max=lm)
        wd_ = np.clip(wd, a_min=0.0, a_max=dm)
        return wu_, wl_, wd_

    def generation(self, p_and_e, k, b, im, um, lm, dm, c, wu) -> tuple:
        # make sure physical variables' value ranges are correct
        wu0 = wu[0]
        wl0 = wu[1]
        wd0 = wu[2]
        prcp = np.maximum(p_and_e[:, 0], 0.0)  # 比较大小，取大值。
        # get potential evaporation
        pet = np.maximum(p_and_e[:, 1] * k, 0.0)
        # wm
        wm = um + lm + dm
        # if wu0 is None:
        #     # just an initial value
        #     wu0 = 0.6 * um
        # if wl0 is None:
        #     wl0 = 0.6 * lm
        # if wd0 is None:
        #     wd0 = 0.6 * dm
        w0_ = wu0 + wl0 + wd0

        # w0 need locate in correct range so that following calculation could be right
        # To make sure float data's calculation is correct, we'd better minus a precision (1e-5)
        w0 = np.minimum(w0_, wm - 1e-5)

        # Calculate the amount of evaporation from storage
        # 三层蒸散发
        eu, el, ed = self.calculate_evap(lm, c, wu0, wl0, prcp, pet)
        e = eu + el + ed

        # Calculate the runoff generated by net precipitation
        prcp_difference = prcp - e
        pe = np.maximum(prcp_difference, 0.0)  # 取值不小于零
        r, rim = self.calculate_prcp_runoff(b, im, wm, w0, pe)  # 蓄满产流
        # Update wu, wl, wd
        wu, wl, wd = self.calculate_w_storage(
            um, lm, dm, wu0, wl0, wd0, eu, el, ed, prcp_difference, r
        )

        return (r, rim, e, pe), (wu, wl, wd)

    def sources(self, pe, r, sm, ex, ki, kg, s0=None, fr0=None) -> tuple:
        # maximum free water storage capacity in a basin
        ms = sm * (1.0 + ex)
        if fr0 is None:
            fr0 = 0.1
        if s0 is None:
            s0 = 0.5 * sm
        precision = 1e-5
        # For free water storage, because s is related to fr and s0 and fr0 are both values of last period,
        # we have to trans the initial value of s from last period to this one.
        # both WHS（流域水文模拟）'s sample code and HF（水文预报） use s = fr0 * s0 / fr.
        # I think they both think free water reservoir as a cubic tank. Its height is s and area of bottom rectangle is fr
        # but the problem is we will have a cubic tank with varying bottom and height, and fixed boundary (sm is fixed)
        # -> so strange !!! I think maybe 2-sources xaj is more interpretable
        # especially when r=0 then fr0=0, the free water cannot disappear immediately, so we have to use s = s0, fr=fr0
        # fr's formula could be found in Eq. 9 in "Analysis of parameters of the XinAnJiang model",
        # Here our r doesn't include rim, so there is no need to remove rim from r; this is also the method in 《水文预报》（HF）
        fr = np.where(r > 0.0, r / (pe + 0.00000001), fr0)
        if np.isnan(fr).any():
            raise ArithmeticError("Please check pe's data! there may be 0.0")
        ss = np.minimum(fr0 * s0 / fr, sm - precision)
        au = ms * (1.0 - (1.0 - ss / sm) ** (1.0 / (1.0 + ex)))
        if np.isnan(au).any():
            raise ValueError(
                "Error： NaN values detected. Try set clip function or check your data!!!"
            )

        rs = np.where(
            pe > 0.0,
            np.where(
                pe + au < ms,
                # equation 2-85 in HF
                # set precision to guarantee float data's calculation is correct
                fr * (pe - sm + ss + sm * ((1 - np.minimum(pe + au, ms - precision) / ms) ** (1 + ex))),
                # equation 2-86 in HF
                fr * (pe + ss - sm),
            ),
            np.full(r.shape, 0.0),
        )
        rs = np.clip(rs, a_min=np.full(rs.shape, 0.0), a_max=r)
        # equation 2-87 in HF, some free water leave, so we update free water storage
        s = ss + (r - rs) / fr
        if np.isnan(s).any():
            raise ArithmeticError("Please check fr's data! there may be 0.0")
        s = np.minimum(s, sm)
        # equation 2-88 in HF, next interflow and ground water will be released from the updated free water storage
        # We use the period average runoff as input and the general unit period is day.
        # Hence, we directly use ki and kg rather than ki_{Δt} in books.
        ri = ki * s * fr
        rg = kg * s * fr
        # equation 2-89 in HF; although it looks different with that in WHS, they are actually same
        # Finally, calculate the final free water storage
        s1 = np.clip(s * (1 - ki - kg), a_min=np.full(s.shape, 0.0), a_max=sm)
        return (rs, ri, rg), (s1, fr)

    def sources5mm(self, pe, runoff, sm, ex, ki, kg, s0=None, fr0=None, time_interval_hours=24, book="ShuiWenYuBao", ):
        # 由于Ki、Kg都是以24小时为时段长定义的，需根据时段长转换
        hours_per_day = 24
        # 非整除情况，时段+1
        residue_temp = hours_per_day % time_interval_hours
        if residue_temp != 0:
            residue_temp = 1
        period_num_1d = int(hours_per_day / time_interval_hours) + residue_temp
        # 当kss+kg>1时，根式为偶数运算时，kss_period会成为复数，这里会报错；另外注意分母可能为0，kss不可取0
        # 对kss+kg的取值进行限制，也是符合物理意义的，地下水出流不能超过自身的蓄水。
        kss_period = (1 - (1 - (ki + kg)) ** (1 / period_num_1d)) / (1 + kg / ki)
        kg_period = kss_period * kg / ki

        # 流域最大点自由水蓄水容量深
        smm = sm * (1 + ex)
        if s0 is None:
            s0 = 0.60 * sm
        if fr0 is None:
            fr0 = 0.02
        fr = np.where(pe > 1e-5, runoff / pe, fr0)
        fr = np.clip(fr, 0.001, 1)

        # 净雨分5mm一段进行计算，因为计算时在FS/FR ~ SMF'关系图上开展，即计算在产流面积上开展，所以用PE做净雨.分段为了差分计算更精确。
        if runoff < 5:
            n = 1
        else:
            residue_temp = runoff % 5
            if residue_temp != 0:
                residue_temp = 1
            n = int(runoff / 5) + residue_temp
        # 整除了就是5mm，不整除就少一些，差分每段小了也挺好
        rn = runoff / n
        pen = pe / n
        kss_d = (1 - (1 - (kss_period + kg_period)) ** (1 / n)) / (
                1 + kg_period / kss_period
        )
        kg_d = kss_d * kg_period / kss_period

        rs = rss = rg = 0

        s_ds = []
        fr_ds = []
        s_ds.append(s0)
        fr_ds.append(fr0)

        for j in range(n):
            # 因为产流面积随着自由水蓄水容量的变化而变化，每5mm净雨对应的产流面积肯定是不同的，因此fr是变化的
            fr0_d = fr_ds[j]
            s0_d = s_ds[j]
            fr_d = 1 - (1 - fr) ** (1 / n)
            s_d = fr0_d * s0_d / fr_d

            if book == "ShuiWenYuBao":
                ms = smm
                if s_d > sm:
                    s_d = sm
                au = ms * (1 - (1 - s_d / sm) ** (1 / (1 + ex)))
                if pen + au >= ms:
                    rs_j = (pen + s_d - sm) * fr_d
                else:
                    rs_j = (pen - sm + s_d + sm * (1 - (pen + au) / ms) ** (ex + 1)) * fr_d
                s_d = s_d + (rn - rs_j) / fr_d
                rss_j = s_d * kss_d * fr_d
                rg_j = s_d * kg_d * fr_d
                s_d = s_d * (1 - rss_j + rg_j)

            elif book == "GongChengShuiWenXue":
                smmf = smm * (1 - (1 - fr_d) ** (1 / ex))
                smf = smmf / (1 + ex)
                # 如果出现s_d>smf的情况，说明s_d = fr0_d * s0_d / fr_d导致的计算误差不合理，需要进行修正。
                if s_d > smf:
                    s_d = smf
                au = smmf * (1 - (1 - s_d / smf) ** (1 / (1 + ex)))
                if pen + au >= smmf:
                    rs_j = (pen + s_d - smf) * fr_d
                    rss_j = smf * kss_d * fr_d
                    rg_j = smf * kg_d * fr_d
                    s_d = smf - (rss_j + rg_j) / fr_d
                else:
                    rs_j = (
                                   pen - smf + s_d + smf * (1 - (pen + au) / smmf) ** (ex + 1)
                           ) * fr_d
                    rss_j = (pen - rs_j / fr_d + s_d) * kss_d * fr_d
                    rg_j = (pen - rs_j / fr_d + s_d) * kg_d * fr_d
                    s_d = s_d + pen - (rs_j + rss_j + rg_j) / fr_d
            else:
                raise NotImplementedError(
                    "We don't have this implementation! Please chose 'ShuiWenYuBao' or 'GongChengShuiWenXue'!!"
                )
            rs = rs + rs_j
            rss = rss + rss_j
            rg = rg + rg_j
            # 赋值s_d和fr_d到数组中，以给下一段做初值
            s_ds.append(s_d)
            fr_ds.append(fr_d)

        return (rs, rss, rg), (s_ds[-1], fr_ds[-1])

    def linear_reservoir(self, x, weight, last_y=None):
        weight1 = 1 - weight
        if last_y is None:
            last_y = np.full(weight.shape, 0.001)
        y = weight * last_y + weight1 * x
        return y

    def xaj(self, p_and_e, xaj_params: Union[np.array, list], return_state=False, kernel_size=15, warmup_length=30,
            source_type="sources", source_book="ShuiWenYuBao", ) -> Union[tuple, np.array]:
        # params
        # param_ranges = OrderedDict(
        #     # {
        #     #     "K": [0.5, 2.0],  # 蒸散发能力折算系数
        #     #     "B": [0.1, 0.4],  # 蓄水容量曲线指数
        #     #     "IM": [0.01, 0.1],  # 不透水面积
        #     #     "UM": [0.0, 20.0],  # 上层UM    WM（张力水容量）
        #     #     "LM": [60.0, 90.0],  # 下层LM
        #     #     "DM": [60.0, 120.0],  # 与深层DM三层
        #     #     "C": [0.0, 0.2],  # 深层蒸散发系数
        #     #     "SM": [1, 100.0],  # 表层土自由水容量
        #     #     "EX": [1.0, 1.5],  # 表层自由水蓄水容量曲线的方次
        #     #     "KI": [0.0, 0.7],  # 壤中流的出流系数
        #     #     "KG": [0.0, 0.7],  # 表层自由水蓄水库对地下水的出流系数
        #     #     "CS": [0.0, 1.0],  # 河网蓄水消退系数
        #     #     "L": [1.0, 10.0],  # unit is day   滞后演算法中的滞后时间
        #     #     "CI": [0.0, 0.9],  # 深层壤中流的消退系数
        #     #     "CG": [0.98, 0.998],  # 地下水库的消退系数
        #     # }
        #     json.load(open(r'.\param_ranges.json', 'r'))
        # )
        # xaj_params = [(value[1] - value[0]) * params[:, i] + value[0] for i, (key, value) in
        #               enumerate(param_ranges.items())]
        k = xaj_params[0]
        b = xaj_params[1]
        im = xaj_params[2]
        um = xaj_params[3]
        lm = xaj_params[4]
        dm = xaj_params[5]
        c = xaj_params[6]
        sm = xaj_params[7]
        ex = xaj_params[8]
        ki = xaj_params[9]
        kg = xaj_params[10]
        # ki+kg should be smaller than 1; if not, we scale them
        ki = np.where(ki + kg < 1.0, ki, 1 / ((ki + kg) * ki + 0.000001))
        kg = np.where(ki + kg < 1.0, kg, 1 / ((ki + kg) * kg + 0.000001))
        cs = xaj_params[11]
        l = xaj_params[12]
        ci = xaj_params[13]
        cg = xaj_params[14]

        # 预热水文模型
        if warmup_length > 0:
            p_and_e_warmup = p_and_e[0:warmup_length, :, :]
            _, w0, s0, fr0, qi0, qg0 = self.xaj(p_and_e_warmup, xaj_params, return_state=True, kernel_size=kernel_size,
                                                warmup_length=0, )
        else:
            w0 = (0.5 * um, 0.5 * lm, 0.5 * dm)
            s0 = 0.5 * sm
            fr0 = np.full(ex.shape, 0.1)
            qi0 = np.full(ci.shape, 0.1)
            qg0 = np.full(cg.shape, 0.1)

        # state_variables
        inputs = p_and_e[warmup_length:, :, :]
        runoff_ims_ = np.full(inputs.shape[:2], 0.0)
        rss_ = np.full(inputs.shape[:2], 0.0)
        ris_ = np.full(inputs.shape[:2], 0.0)
        rgs_ = np.full(inputs.shape[:2], 0.0)

        for i in range(inputs.shape[0]):
            """产汇流计算"""
            if i == 0:
                # r为地面径流，rim为不透水面积的产流量。
                (r, rim, e, pe), w = self.generation(inputs[i, :, :], k, b, im, um, lm, dm, c, w0)
                # 三水源
                if source_type == "sources":
                    (rs, ri, rg), (s, fr) = self.sources(pe, r, sm, ex, ki, kg, s0, fr0)
                elif source_type == "sources5mm":
                    (rs, ri, rg), (s, fr) = self.sources5mm(pe, r, sm, ex, ki, kg, s0, fr0, book=source_book)
                else:
                    raise NotImplementedError("No such divide-sources method")
            else:
                (r, rim, e, pe), w = self.generation(inputs[i, :, :], k, b, im, um, lm, dm, c, w)
                if source_type == "sources":
                    (rs, ri, rg), (s, fr) = self.sources(pe, r, sm, ex, ki, kg, s, fr)
                elif source_type == "sources5mm":  # 在自由水蓄水库的计算中，存在差分计算误差，为了消除影响，可采用5mm净雨分一段，进一步处理。
                    (rs, ri, rg), (s, fr) = self.sources5mm(pe, r, sm, ex, ki, kg, s, fr, book=source_book)
                else:
                    raise NotImplementedError("No such divide-sources method")
            # impevious part is pe * im
            runoff_ims_[i, :] = rim
            # so for non-imprvious part, the result should be corrected
            rss_[i, :] = rs * (1 - im)
            ris_[i, :] = ri * (1 - im)
            rgs_[i, :] = rg * (1 - im)
        # seq, batch, feature
        # runoff_im = np.expand_dims(runoff_ims_, axis=2)
        # rss = np.expand_dims(rss_, axis=2)

        # 坡地汇流计算
        qs = np.full(inputs.shape[:2], 0.0)
        qt = np.full(inputs.shape[:2], 0.0)

        for i in range(inputs.shape[0]):
            # 壤中流与地下径流
            if i == 0:
                qi = self.linear_reservoir(ris_[i], ci, qi0)
                qg = self.linear_reservoir(rgs_[i], cg, qg0)
            else:
                qi = self.linear_reservoir(ris_[i], ci, qi)
                qg = self.linear_reservoir(rgs_[i], cg, qg)
            # 地面径流
            qs_ = rss_[i]
            qt[i, :] = qs_ + qi + qg  # 河网总入流

        # 河网汇流计算
        # params_route = {"L": l, "CR": cs}
        # qs = xaj_river.network_route(qt, params_route)

        for j in range(len(l)):
            lag = int(l[j])
            for i in range(lag):
                qs[i, j] = qt[i, j]
            for i in range(lag, inputs.shape[0]):
                qs[i, j] = cs[j] * qs[i - 1, j] + (1 - cs[j]) * qt[i - lag, j]

        # seq, batch, feature
        q_sim = np.expand_dims(qs, axis=2)
        if return_state:
            return q_sim, w, s, fr, qi, qg
        return q_sim

    def statRmse(self, target, pred, axis=0):
        return np.sqrt(np.nanmean((pred - target) ** 2, axis=axis))

    def evaluate(self, individual, rainfall_flood_processes, warmup_length, model):
        # print("Calculate fitness:")
        params = np.array(individual).reshape(1, -1)
        # 参数与处理？
        params = transform_param(params)
        mse = np.array([])
        for rainfall_flood_precess in rainfall_flood_processes:
            x_input, y_true = rainfall_flood_precess[:, :, 0:2], rainfall_flood_precess[:, :, -1:]
            if model == "xaj":
                sim = self.xaj(x_input, params, warmup_length=warmup_length)
            else:
                raise NotImplementedError("We don't provide this model now")

            rmses = self.statRmse(y_true[warmup_length:, :, :], sim)
            rmse_tp = rmses.mean(axis=0)
            mse = np.append(mse, rmse_tp)
        rmse = np.array([np.array(mse).mean()])
        print('MSE:', str(rmse))
        return rmse

    def checkBounds(self, min, max):
        """
        A decorator to set bounds for individuals in a population
        """

        def decorator(func):
            def wrapper(*args, **kargs):
                offspring = func(*args, **kargs)
                for child in offspring:
                    for i in range(len(child)):
                        if child[i] > max:
                            child[i] = max
                        elif child[i] < min:
                            child[i] = min
                return offspring

            return wrapper

        return decorator

    def calibrate_by_ga(self, rainfall_flood_processes, warmup_length=30, model="xaj", param_num=15, optimal_path=None,
                        **ga_param):
        """
        Use GA algorithm to find optimal parameters for hydrologic models

        Returns
        -------
        toolbox.population
            optimal_params
        """

        # 优化目标
        creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
        # 个体生成
        creator.create("Individual", list, fitness=creator.FitnessMin)
        # 工具箱：注册参数信息：交叉,变异,保留个体,评价函数
        toolbox = base.Toolbox()
        toolbox.register("attribute", random.random)
        toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attribute, n=param_num, )
        toolbox.register("population", tools.initRepeat, list, toolbox.individual)
        # 交叉
        toolbox.register("mate", tools.cxTwoPoint)
        # 个体变异
        toolbox.register("mutate", tools.mutGaussian, mu=0, sigma=1, indpb=0.1)
        # 选择
        toolbox.register("select", tools.selTournament, tournsize=3)
        # 评价
        toolbox.register("evaluate", self.evaluate, rainfall_flood_processes=rainfall_flood_processes,
                         warmup_length=warmup_length, model=model, )

        toolbox.decorate("mate", self.checkBounds(MIN, MAX))
        toolbox.decorate("mutate", self.checkBounds(MIN, MAX))

        pop = toolbox.population(n=ga_param['pop_num'])  # 初始化种群
        # cxpb  is the probability with which two individuals are crossed
        # mutpb is the probability for mutating an individual
        cxpb, mutpb = ga_param["cross_prob"], ga_param["mut_prob"]

        # Evaluate the entire population
        fitnesses = map(toolbox.evaluate, pop)  # map函数的第一个参数是一个函数，第二个参数是一个序列，里面的每个元素作为函数的参数进行计算和判断。函数返回值则被作为新的元素存储起来。
        tmp = []
        for ind, fit in zip(pop, fitnesses):
            # print(fit)
            ind.fitness.values = fit
            tmp.append(fit[0])

        for g in range(ga_param["run_counts"]):
            # Select the next generation individuals
            offspring = toolbox.select(pop, len(pop))
            # Clone the selected individuals
            offspring = list(map(toolbox.clone, offspring))

            # Apply crossover and mutation on the offspring
            for child1, child2 in zip(offspring[::2], offspring[1::2]):
                if random.random() < cxpb:
                    toolbox.mate(child1, child2)
                    del child1.fitness.values
                    del child2.fitness.values

            for mutant in offspring:
                if random.random() < mutpb:
                    toolbox.mutate(mutant)
                    del mutant.fitness.values

            # Evaluate the individuals with an invalid fitness
            invalid_ind = [ind for ind in offspring if not ind.fitness.valid]
            fitnesses = map(toolbox.evaluate, invalid_ind)
            tmp = []
            for ind, fit in zip(invalid_ind, fitnesses):
                ind.fitness.values = fit
                tmp.append(fit[0])
            # viz
            if tmp:
                fit_min = min(tmp)
                minfit_idx = tmp.index(fit_min)
            else:
                fit_min = 10
            # viz.line([fit_min], [g], win='%s' % optimal_path.split('\\')[-1][:-4], update='append')

            # The population is entirely replaced by the offspring
            pop[:] = offspring
            print(g)
        # print(pop)
        # 保存一个最牛的
        # np.save(optimal_path, pop[minfit_idx, :])
        # transform_param(np.array(pop[minfit_idx]))
        s = np.array(pop[minfit_idx]).reshape(1, -1)
        res = param2json(transform_param(s))
        serialize_json(res, optimal_path)
        # np.array(individual).reshape(1, -1)

        return pop


def main(args, datas, optimal_name):
    warmup = args['warmup_length']
    model = args['model_name']
    algo_param = args['algorithm_param']
    optimal_path = r'%s\%s.json' % (args['optimal_path'], optimal_name)
    # 降雨-蒸发 -- 流量
    CalibrateXAJ_by_ga = CalibrateXAJ()
    CalibrateXAJ_by_ga.calibrate_by_ga(datas, warmup_length=warmup, model=model, optimal_path=optimal_path,
                                       **algo_param)


def train(action_dict):
    # 超参数
    # action_dict = json.load(open(r'.\param.json', 'r'))

    file_dir = action_dict['data_dir']
    # datas
    for root, dirs, files in os.walk(file_dir):
        for file in files:
            name = file.split('.')[0]
            basin_area = action_dict['%s_area' % name]
            sheets = pd.ExcelFile(os.path.join(action_dict["data_dir"], file))
            datas = []
            for sheet in sheets.sheet_names:
                data = pd.read_excel(os.path.join(action_dict["data_dir"], file), sheet_name=sheet)

                # 数据预处理
                data['rainfall'].fillna(0, inplace=True)
                data['rainfall'].replace(' ', 0, inplace=True)
                data['q'].replace(' ', np.nan, inplace=True)
                data.loc[:, 'q'] = round(data.loc[:, 'q'].interpolate(method='linear', axis=0), 2)

                p = data.loc[:, 'rainfall']
                # 统一量纲,将流量转化为径流深。
                q = abs(data.loc[:, 'q'] / (basin_area / (3.6 * action_dict['dt'])))
                # 蒸发量，设为常数。
                e = np.full([data.shape[0], 1], action_dict['evaporation'])
                data_all = []
                for p_, q_, e_ in zip(p, q, e):
                    # s = np.array([np.array([p_]), np.array([e_]), np.array([q_])])
                    data_all.append(np.array([np.array([float(p_), float(e_), float(q_)])]))
                datas.append(np.array(data_all))
            main(action_dict, datas, name)
            print('已完成一个站点的率定')
    print('complete all!')


def xaj_load(action_dict):
    # action_dict = json.load(open(r'.\param.json', 'r'))
    file_dir = action_dict['pred_data_path']
    # datas
    for root, dirs, files in os.walk(file_dir):
        for file in files:
            name = file.split('.')[0]
            file_type = file.split('.')[1]
            # s = os.path.join(action_dict["pred_data_path"], file
            if file_type in ["xls", "XLS", "xlsx", "XLSX"]:
                rainfall_flood_precess = pd.read_excel(os.path.join(action_dict["pred_data_path"], file))
            elif file_type == "csv":
                rainfall_flood_precess = pd.read_csv(os.path.join(action_dict["pred_data_path"], file))
            else:
                try:
                    rainfall_flood_precess = pd.read_csv(os.path.join(action_dict["pred_data_path"], file),
                                                         encoding="utf-8", sep="\t")
                except:
                    rainfall_flood_precess = pd.read_csv(os.path.join(action_dict["pred_data_path"], file),
                                                         encoding="utf-8", sep=",")

            rainfall_flood_precess['rainfall'].fillna(0, inplace=True)
            rainfall_flood_precess['rainfall'].replace(' ', 0, inplace=True)
            p = rainfall_flood_precess.loc[:, 'rainfall']
            e = rainfall_flood_precess.loc[:, 'evaporation']
            x_input = []
            for p_, e_ in zip(p, e):
                x_input.append(np.array([np.array([float(p_), float(e_)])]))
            x_input = np.array(x_input)
            # 载入参数  直接加载现成的模型参数
            params_dict = OrderedDict(
                json.load(open(os.path.join(action_dict["optimal_path"], "%s.json" % name), 'r'))
            )
            params = np.array([])
            for key, values in params_dict.items():
                params = np.append(params, values)
            paramssssssss = np.load((os.path.join(action_dict["optimal_path"], "%s.npy" % name)))[1, :]

            params = np.array(params)
            sim = xaj(x_input, params, warmup_length=action_dict['warmup_length']).squeeze()
            basin_area = action_dict['%s_area' % name]
            lines = [str(round(inform * (basin_area / (3.6 * action_dict['dt'])), 3)) for inform in sim]
            with open(os.path.join(action_dict["pred_res"], "%s.txt" % name), mode="w", encoding="gbk") as f1:
                for i in lines:
                    f1.write(i + '\n')
    print('complete all')


def transform_param(params):
    param_ranges = OrderedDict(json.load(open(r'.\param_ranges.json', 'r')))
    xaj_params = [(value[1] - value[0]) * params[:, i] + value[0] for i, (key, value) in
                  enumerate(param_ranges.items())]
    # k = xaj_params[0]
    # b = xaj_params[1]
    # im = xaj_params[2]
    # um = xaj_params[3]
    # lm = xaj_params[4]
    # dm = xaj_params[5]
    # c = xaj_params[6]
    # sm = xaj_params[7]
    # ex = xaj_params[8]
    # ki = xaj_params[9]
    # kg = xaj_params[10]
    # # ki+kg should be smaller than 1; if not, we scale them
    # ki = np.where(ki + kg < 1.0, ki, 1 / ((ki + kg) * ki + 0.000001))
    # kg = np.where(ki + kg < 1.0, kg, 1 / ((ki + kg) * kg + 0.000001))
    # cs = xaj_params[11]
    # l = xaj_params[12]
    # ci = xaj_params[13]
    # cg = xaj_params[14]
    #
    # res = {
    #     "K": k,  # 蒸散发能力折算系数
    #     "B": b,  # 蓄水容量曲线指数
    #     "IM": im,  # 不透水面积
    #     "UM": um,  # 上层UM    WM（张力水容量）
    #     "LM": lm,  # 下层LM
    #     "DM": dm,  # 与深层DM三层
    #     "C": c,  # 深层蒸散发系数
    #     "SM": sm,  # 表层土自由水容量
    #     "EX": ex,  # 表层自由水蓄水容量曲线的方次
    #     "KI": ki,  # 壤中流的出流系数
    #     "KG": kg,  # 表层自由水蓄水库对地下水的出流系数
    #     "CS": cs,  # 河网蓄水消退系数
    #     "L": l,  # unit is day   滞后演算法中的滞后时间
    #     "CI": ci,  # 深层壤中流的消退系数
    #     "CG": cg,  # 地下水库的消退系数
    # }
    return xaj_params


def param2json(xaj_params):
    # xaj_params = [float(param) for param in xaj_params]
    k = xaj_params[0]
    b = xaj_params[1]
    im = xaj_params[2]
    um = xaj_params[3]
    lm = xaj_params[4]
    dm = xaj_params[5]
    c = xaj_params[6]
    sm = xaj_params[7]
    ex = xaj_params[8]
    ki = xaj_params[9]
    kg = xaj_params[10]
    # ki+kg should be smaller than 1; if not, we scale them
    ki = np.where(ki + kg < 1.0, ki, 1 / ((ki + kg) * ki + 0.000001))
    kg = np.where(ki + kg < 1.0, kg, 1 / ((ki + kg) * kg + 0.000001))
    cs = xaj_params[11]
    l = xaj_params[12]
    ci = xaj_params[13]
    cg = xaj_params[14]

    res = {
        "K": k,  # 蒸散发能力折算系数
        "B": b,  # 蓄水容量曲线指数
        "IM": im,  # 不透水面积
        "UM": um,  # 上层UM    WM（张力水容量）
        "LM": lm,  # 下层LM
        "DM": dm,  # 与深层DM三层
        "C": c,  # 深层蒸散发系数
        "SM": sm,  # 表层土自由水容量
        "EX": ex,  # 表层自由水蓄水容量曲线的方次
        "KI": ki,  # 壤中流的出流系数
        "KG": kg,  # 表层自由水蓄水库对地下水的出流系数
        "CS": cs,  # 河网蓄水消退系数
        "L": l,  # unit is day   滞后演算法中的滞后时间
        "CI": ci,  # 深层壤中流的消退系数
        "CG": cg,  # 地下水库的消退系数
    }
    for key, value in res.items():
        res[key] = round(float(value), 4)
    return res


def unserialize_json(my_file):
    with open(my_file, "r") as fp:
        my_object = json.load(fp)
    return my_object


def serialize_json(my_dict, my_file):
    with open(my_file, "w") as FP:
        json.dump(my_dict, FP)


if __name__ == "__main__":
    print("Fix the bug，please call 17673653855，Mr.Ding")
    action_dict = json.load(open(r'.\param.json', 'r'))
    action_dict['role'] = 1
    if action_dict['role']:
        train(action_dict)
    else:
        xaj_load(action_dict)
